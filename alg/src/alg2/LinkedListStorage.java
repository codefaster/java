package alg2;public class LinkedListStorage implements Datenspeicher {	protected ListenGlied root;	protected ListenGlied last;		public LinkedListStorage() {		root = new ListenGlied(null);		last = new ListenGlied(null);	}		public ListenGlied getGlied(Keyable content) {		ListenGlied current = root;		while (current.getContent() != content && current.getContent() != null) {			current = current.getNext();		}		return current;	}	public ListenGlied getByIndex(int i) {		ListenGlied current = root;		int counter = 0;		while (i <= counter) {			current = current.getNext();			counter ++;		}		return current;	}/*	Fügt das gegebene Objekt o in die Liste ein und zwar vor dem gegebenen Listenglied g.  *	Ist das gegebene Listenglied null macht die Methode nichts. */	public ListenGlied insertBefore(ListenGlied g, Keyable content) {		ListenGlied successor = getGlied(content);		ListenGlied predecessor = getGlied(successor.getContent());		g.next = successor;		predecessor.next = g;		return g;	}	/*	Fü̈gt das gegebene Objekt o in die Liste ein und zwar nach dem gegebenen Listenglied g. *	Ist das gegebene Listenglied null macht die Methode nichts. */ 	//N E E D S C O R R E C T I O N	public ListenGlied insertAfter(ListenGlied g, Keyable content) {		ListenGlied predecessor = getGlied(content);		ListenGlied successor = predecessor.getNext();		g.next = successor;		predecessor.next = g;		return g;	}			public void insert(Keyable o) {		if (root.isEmpty()) {			root.o = o;			last = root;//			return;		}		ListenGlied nextToLast = last;		last = new ListenGlied(o);		nextToLast.next = last;	}		public Keyable get(int key) {		ListenGlied current = root;		while (current.hasNext() && current.getContent().getKey()!=key) {			current = current.getNext();		}		return current.getContent();	}	public Keyable getMaximum() {		ListenGlied current = root;		Keyable max = current.getContent();		while (current.hasNext()) {			current = current.getNext();			if (current.getContent().getKey() >= max.getKey()) {				max = current.getContent();			}		}		return max;	}	public Keyable getMinimum() {		ListenGlied current = root;		Keyable min = current.getContent();		while (current.hasNext()) {			current = current.getNext();			if (current.getContent().getKey() <= min.getKey()) {				min = current.getContent();			}		}		return min;	}	public Keyable remove(int index) {		ListenGlied predecessor = getByIndex(index-1);		ListenGlied current = predecessor.next;		ListenGlied next = current.next;		predecessor.next=next;		return current.getContent(); //Check if cor.	}	public void remove(Keyable o) {		ListenGlied predecessor = getGlied(o);		ListenGlied current = predecessor.next;		ListenGlied next = current.next;		predecessor.next=next;	}	public boolean contains(Keyable o) {		return contains(o.getKey());	}	public boolean contains(int key) {		boolean exists=false;		ListenGlied current = root;		while (current.hasNext()) {			current = current.getNext();			if (current.o.getKey() == key) {				exists=true;			}		}		return exists;	}	public Keyable getSuccessor(Keyable o) {		return getGlied(o).getNext().getContent();	}	public Keyable getPredecessor(Keyable o) {		ListenGlied current = root;		while (current.next != o && current.getContent() != null) {			current = current.getNext();		}		return current.getContent();	}	public int size() {		int size = 0;		ListenGlied current = root;		while (current.hasNext()) {			current = current.next;			size++;		}		return size;	}	public void clear() {		ListenGlied current = root;		while (current.getContent() != null) {			ListenGlied predecessor = current;			predecessor.next = null;			current = current.getNext();		}	}}
package pr2.a06;import java.awt.Point;public class Circle extends Point {	protected int r;	protected int rotation;	public Circle(int x, int y, int r) {		super(x, y);		this.r = r;		this.rotation = 0;	}	public Circle(Circle c) {		this(c.x, c.y, c.r);	}	public Point getCenter() {		return new Point(x + r, y + r);	}	public Circle shrink(int size) {		return new Circle(x + size, y + size, r - size);	}	public void makeCenter() {		x = x - r;		y = y - r;	}	public void alignLeft() {		x = x - r * 2;	}	public void alignRight() {		x = x + r * 2;	}	public void alignUp() {		y = y - r * 2;	}	public void alignDown() {		y = y + r * 2;	}	public void compensateRotation() {		if (rotation >= 0 && rotation <= 180) {			alignLeft();		}		if (rotation >= 180 && rotation <= 360) {		}	}	public int getR() {		return r;	}	public int getD() {		return r * 2;	}	public void moveRelative(int dx, int dy) {		x += dx;		y += dy;	}	public void setPosition(int x, int y) {		this.x = x;		this.y = y;	}	public void rotateRel(Point axisPoint, int angle) {		double angleD = angle * Math.PI / 180;		x = (int) Math.round((Math.cos(angle) * (x - axisPoint.x)				- Math.sin(angleD) * (y - axisPoint.y) + axisPoint.x));		y = (int) Math.round((Math.sin(angle) * (x - axisPoint.x)				+ Math.cos(angleD) * (y - axisPoint.y) + axisPoint.y));	}	public void rotateAbs(Circle axisCircle, double angle, boolean compensate) {		rotateAbs(axisCircle, angle);		if (compensate == true) {			compensateRotation();		}	}	public void rotateAbs(Circle axisCircle, double angle) {		rotation += angle;		final int DEG_COMP = 90;		final Point CENTER = axisCircle.getCenter();		double angleD = (angle - DEG_COMP) * Math.PI / 180;		x = (int) Math.round((CENTER.x + axisCircle.getR() * Math.cos(angleD)));		y = (int) Math.round((CENTER.y + axisCircle.getR() * Math.sin(angleD)));	}}